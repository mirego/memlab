/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * @oncall memory_lab
 */
import type { HaltOrThrowOptions, HeapNodeIdSet, ShellOptions, StringRecord } from './Types';
import { MemLabConfig } from './Config';
import type { Browser, Page } from 'puppeteer';
import type { AnyAyncFunction, AnyOptions, E2EStepInfo, IHeapSnapshot, IHeapNode, IHeapEdge, IScenario, ILeakFilter, LeakTracePathItem, RawHeapSnapshot, Nullable, Optional } from './Types';
declare function isHermesInternalObject(node: IHeapNode): boolean;
declare function isStackTraceFrame(node: IHeapNode): boolean;
declare function isFiberNode(node: Optional<IHeapNode>): boolean;
declare function isDetachedFiberNode(node: IHeapNode): boolean;
declare function isDOMInternalNode(node: Optional<IHeapNode>): boolean;
declare function isGlobalHandlesNode(node: Optional<IHeapNode>): boolean;
declare function isDetachedDOMNode(node: Optional<IHeapNode>, args?: AnyOptions): boolean;
declare function isWeakMapEdge(edge: IHeapEdge): boolean;
declare function isWeakMapEdgeToKey(edge: IHeapEdge): boolean;
declare function isWeakMapEdgeToValue(edge: IHeapEdge): boolean;
declare function isEssentialEdge(nodeIndex: number, edgeType: string, rootNodeIndex: number): boolean;
declare function isFiberNodeDeletionsEdge(edge: IHeapEdge): boolean;
declare function isBlinkRootNode(node: IHeapNode): boolean;
declare function isPendingActivityNode(node: IHeapNode): boolean;
declare function isDOMNodeIncomplete(node: IHeapNode): boolean;
declare function isXMLDocumentNode(node: IHeapNode): boolean;
declare function isHTMLDocumentNode(node: IHeapNode): boolean;
declare function isDOMTextNode(node: IHeapNode): boolean;
declare function isCppRootsNode(node: IHeapNode): boolean;
declare function isRootNode(node: IHeapNode, opt?: AnyOptions): boolean;
declare function isDirectPropEdge(edge: IHeapEdge): boolean;
declare function isReturnEdge(edge: IHeapEdge): boolean;
declare function isReactPropsEdge(edge: IHeapEdge): boolean;
declare function isReactFiberEdge(edge: IHeapEdge): boolean;
declare function hasReactEdges(node: IHeapNode): boolean;
declare function isHostRoot(node: IHeapNode): boolean;
declare function checkIsChildOfParent(node: IHeapNode): boolean;
type IterateCallback = (node: IHeapNode) => {
    stop: boolean;
} | void;
declare function iterateChildFiberNodes(node: Nullable<IHeapNode>, cb: IterateCallback): void;
declare function iterateDescendantFiberNodes(node: IHeapNode, iteratorCB: IterateCallback): void;
declare function getNodesIdSet(snapshot: IHeapSnapshot): Set<number>;
declare function getConditionalDominatorIds(ids: Set<number>, snapshot: IHeapSnapshot, condCb: (node: IHeapNode) => boolean): Set<number>;
declare function setIsAlternateNode(node: Nullable<IHeapNode>): void;
declare function isAlternateNode(node: IHeapNode): boolean;
declare function setIsRegularFiberNode(node: IHeapNode): void;
declare function isRegularFiberNode(node: IHeapNode): boolean;
declare function hasHostRoot(node: IHeapNode): boolean;
declare function markDetachedFiberNode(node: IHeapNode): boolean;
type IterateNodeCallback = (node: IHeapNode, snapshot: IHeapSnapshot) => boolean;
declare function filterNodesInPlace(idSet: Set<number>, snapshot: IHeapSnapshot, cb: IterateNodeCallback): void;
declare function applyToNodes(idSet: Set<number>, snapshot: IHeapSnapshot, cb: (node: IHeapNode, snapshot: IHeapSnapshot) => void, options?: AnyOptions): void;
declare function loadLeakFilter(filename: string): ILeakFilter;
declare function loadScenario(filename: string): IScenario;
declare function getScenarioName(scenario: IScenario): string;
declare function getSnapshotFromFile(filename: string, options: AnyOptions): Promise<IHeapSnapshot>;
declare function getSnapshotNodeIdsFromFile(filename: string, options: AnyOptions): Promise<Set<number>>;
declare function getWeakMapEdgeKeyId(edge: IHeapEdge): number;
declare function isDocumentDOMTreesRoot(node: IHeapNode): boolean;
declare function getEdgeByNameAndType(node: Nullable<IHeapNode>, edgeName: string | number, type?: string): Nullable<IHeapEdge>;
declare function isStringNode(node: IHeapNode): boolean;
declare function isSlicedStringNode(node: IHeapNode): boolean;
declare function getStringNodeValue(node: Optional<IHeapNode>): string;
declare function extractClosureNodeInfo(node: IHeapNode): string;
declare function extractFiberNodeInfo(node: IHeapNode): string;
declare function getSimplifiedDOMNodeName(node: IHeapNode): string;
declare function simplifyTagAttributes(str: string, prioritizedAttributes?: Set<string>): string;
declare function stripTagAttributes(str: string): string;
declare function getNumberNodeValue(node: IHeapNode): Nullable<number>;
declare function getBooleanNodeValue(node: IHeapNode): Nullable<boolean>;
declare function getToNodeByEdge(node: Nullable<IHeapNode>, propName: string, propType?: string): Nullable<IHeapNode>;
declare function extractHTMLElementNodeInfo(node: IHeapNode): string;
declare function hasOnlyWeakReferrers(node: IHeapNode): boolean;
declare function getSnapshotSequenceFilePath(): string;
declare function loadTabsOrder(metaFile?: Optional<string>): E2EStepInfo[];
declare function isObjectNode(node: IHeapNode): boolean;
declare function isPlainJSObjectNode(node: IHeapNode): boolean;
declare function pathHasDetachedHTMLNode(path: LeakTracePathItem): boolean;
declare function pathHasEdgeWithIndex(path: LeakTracePathItem, idx: number): boolean;
declare function pathHasEdgeWithName(path: LeakTracePathItem, edgeName: string): boolean;
declare function pathHasNodeOrEdgeWithName(path: LeakTracePathItem, name: Optional<string>): boolean;
declare function getLastNodeId(path: LeakTracePathItem): number;
declare function getReadablePercent(num: number): string;
declare function getReadableBytes(bytes: Optional<number>): string;
declare function getReadableTime(ms: number): string;
declare function shouldShowMoreInfo(node: IHeapNode): boolean;
declare function isDebuggableNode(node: IHeapNode): boolean;
declare function throwError(error: Error): void;
declare function callAsync(f: AnyAyncFunction): void;
declare function checkUninstalledLibrary(ex: Error): void;
declare function closePuppeteer(browser: Browser, pages: Page[], options?: AnyOptions): Promise<void>;
declare function camelCaseToReadableString(str: string, options?: {
    capitalizeFirstWord?: boolean;
}): string;
declare function resolveFilePath(file: string | null): Nullable<string>;
declare function getSnapshotFilesInDir(dir: string): string[];
declare function getSnapshotFilesFromTabsOrder(options?: AnyOptions): string[];
declare function checkSnapshots(options?: {
    snapshotDir?: Optional<string>;
    minSnapshots?: number;
}): void;
export declare function resolveSnapshotFilePath(snapshotFile: Nullable<string>): string;
declare function getSnapshotDirForAnalysis(): string;
declare function getSingleSnapshotFileForAnalysis(): string;
declare function getSnapshotFilePath(tab: E2EStepInfo, options?: {
    workDir?: string;
}): string;
declare function equalOrMatch(v1: any, v2: any): boolean;
declare function getSnapshotFilePathWithTabType(type: string | RegExp): Nullable<string>;
declare function isMeaningfulNode(node: IHeapNode): boolean;
interface IsMeaningFulEdgeParams {
    visited?: Uint8Array;
    queued?: Uint8Array;
    includeString?: boolean;
    excludeWeakMapEdge?: boolean;
    isForward?: boolean;
}
declare function isMeaningfulEdge(edge: IHeapEdge, options?: IsMeaningFulEdgeParams): boolean;
declare function isURLEqual(url1: string, url2: string): boolean;
declare function shuffleArray<T>(array: T[]): T[];
declare function getLeakedNode(path: LeakTracePathItem): IHeapNode | null;
declare function dumpSnapshot(file: string, snapshot: RawHeapSnapshot): void;
declare function markAllDetachedFiberNode(snapshot: IHeapSnapshot): void;
declare function markAlternateFiberNode(snapshot: IHeapSnapshot): void;
declare function getAllDominators(node: IHeapNode): Array<IHeapNode>;
declare function upperCaseFirstCharacter(text: string): string;
declare function repeat(str: string, n: number): string;
declare function normalizeBaseUrl(url: string): string;
declare function haltOrThrow(errorInfo: string | Error, options?: HaltOrThrowOptions): never;
declare function getError(maybeError: unknown): Error;
declare function isNodeDominatedByDeletionsArray(node: IHeapNode): boolean;
declare function getUniqueID(): string;
declare function getClosureSourceUrl(node: IHeapNode): Nullable<string>;
export declare function runShell(command: string, options?: ShellOptions): Nullable<string>;
declare function getRetainedSize(node: IHeapNode): number;
declare function aggregateDominatorMetrics(ids: HeapNodeIdSet, snapshot: IHeapSnapshot, checkNodeCb: (node: IHeapNode) => boolean, nodeMetricsCb: (node: IHeapNode) => number): number;
declare function getLeakTracePathLength(path: LeakTracePathItem): number;
declare function getNumberAtPercentile(arr: number[], percentile: number): number;
declare function mapToObject(map: Map<string, string>): StringRecord;
declare function objectToMap(object: StringRecord): Map<string, string>;
declare function tryToMutePuppeteerWarning(): void;
declare function isStandardNumberToString(input: string): boolean;
declare function setChromiumBinary(config: MemLabConfig, chromiumBinary: string): void;
declare function convertCLIArgsToReadableCommand(args: string[]): string;
declare const _default: {
    aggregateDominatorMetrics: typeof aggregateDominatorMetrics;
    applyToNodes: typeof applyToNodes;
    callAsync: typeof callAsync;
    camelCaseToReadableString: typeof camelCaseToReadableString;
    checkIsChildOfParent: typeof checkIsChildOfParent;
    checkSnapshots: typeof checkSnapshots;
    checkUninstalledLibrary: typeof checkUninstalledLibrary;
    closePuppeteer: typeof closePuppeteer;
    convertCLIArgsToReadableCommand: typeof convertCLIArgsToReadableCommand;
    dumpSnapshot: typeof dumpSnapshot;
    equalOrMatch: typeof equalOrMatch;
    extractClosureNodeInfo: typeof extractClosureNodeInfo;
    extractFiberNodeInfo: typeof extractFiberNodeInfo;
    extractHTMLElementNodeInfo: typeof extractHTMLElementNodeInfo;
    filterNodesInPlace: typeof filterNodesInPlace;
    getAllDominators: typeof getAllDominators;
    getBooleanNodeValue: typeof getBooleanNodeValue;
    getClosureSourceUrl: typeof getClosureSourceUrl;
    getConditionalDominatorIds: typeof getConditionalDominatorIds;
    getEdgeByNameAndType: typeof getEdgeByNameAndType;
    getError: typeof getError;
    getLastNodeId: typeof getLastNodeId;
    getLeakTracePathLength: typeof getLeakTracePathLength;
    getLeakedNode: typeof getLeakedNode;
    getNodesIdSet: typeof getNodesIdSet;
    getNumberAtPercentile: typeof getNumberAtPercentile;
    getNumberNodeValue: typeof getNumberNodeValue;
    getReadableBytes: typeof getReadableBytes;
    getReadablePercent: typeof getReadablePercent;
    getReadableTime: typeof getReadableTime;
    getRetainedSize: typeof getRetainedSize;
    getScenarioName: typeof getScenarioName;
    getSimplifiedDOMNodeName: typeof getSimplifiedDOMNodeName;
    getSingleSnapshotFileForAnalysis: typeof getSingleSnapshotFileForAnalysis;
    getSnapshotDirForAnalysis: typeof getSnapshotDirForAnalysis;
    getSnapshotFilePath: typeof getSnapshotFilePath;
    getSnapshotFilePathWithTabType: typeof getSnapshotFilePathWithTabType;
    getSnapshotFilesFromTabsOrder: typeof getSnapshotFilesFromTabsOrder;
    getSnapshotFilesInDir: typeof getSnapshotFilesInDir;
    getSnapshotFromFile: typeof getSnapshotFromFile;
    getSnapshotNodeIdsFromFile: typeof getSnapshotNodeIdsFromFile;
    getSnapshotSequenceFilePath: typeof getSnapshotSequenceFilePath;
    getStringNodeValue: typeof getStringNodeValue;
    getToNodeByEdge: typeof getToNodeByEdge;
    getUniqueID: typeof getUniqueID;
    getWeakMapEdgeKeyId: typeof getWeakMapEdgeKeyId;
    haltOrThrow: typeof haltOrThrow;
    hasHostRoot: typeof hasHostRoot;
    hasOnlyWeakReferrers: typeof hasOnlyWeakReferrers;
    hasReactEdges: typeof hasReactEdges;
    isAlternateNode: typeof isAlternateNode;
    isBlinkRootNode: typeof isBlinkRootNode;
    isCppRootsNode: typeof isCppRootsNode;
    isDOMInternalNode: typeof isDOMInternalNode;
    isDOMNodeIncomplete: typeof isDOMNodeIncomplete;
    isDOMTextNode: typeof isDOMTextNode;
    isDebuggableNode: typeof isDebuggableNode;
    isDetachedDOMNode: typeof isDetachedDOMNode;
    isDetachedFiberNode: typeof isDetachedFiberNode;
    isDirectPropEdge: typeof isDirectPropEdge;
    isDocumentDOMTreesRoot: typeof isDocumentDOMTreesRoot;
    isEssentialEdge: typeof isEssentialEdge;
    isFiberNode: typeof isFiberNode;
    isFiberNodeDeletionsEdge: typeof isFiberNodeDeletionsEdge;
    isGlobalHandlesNode: typeof isGlobalHandlesNode;
    isHTMLDocumentNode: typeof isHTMLDocumentNode;
    isHermesInternalObject: typeof isHermesInternalObject;
    isHostRoot: typeof isHostRoot;
    isMeaningfulEdge: typeof isMeaningfulEdge;
    isMeaningfulNode: typeof isMeaningfulNode;
    isNodeDominatedByDeletionsArray: typeof isNodeDominatedByDeletionsArray;
    isObjectNode: typeof isObjectNode;
    isPendingActivityNode: typeof isPendingActivityNode;
    isPlainJSObjectNode: typeof isPlainJSObjectNode;
    isReactFiberEdge: typeof isReactFiberEdge;
    isReactPropsEdge: typeof isReactPropsEdge;
    isRegularFiberNode: typeof isRegularFiberNode;
    isReturnEdge: typeof isReturnEdge;
    isRootNode: typeof isRootNode;
    isSlicedStringNode: typeof isSlicedStringNode;
    isStackTraceFrame: typeof isStackTraceFrame;
    isStandardNumberToString: typeof isStandardNumberToString;
    isStringNode: typeof isStringNode;
    isURLEqual: typeof isURLEqual;
    isWeakMapEdge: typeof isWeakMapEdge;
    isWeakMapEdgeToKey: typeof isWeakMapEdgeToKey;
    isWeakMapEdgeToValue: typeof isWeakMapEdgeToValue;
    isXMLDocumentNode: typeof isXMLDocumentNode;
    iterateChildFiberNodes: typeof iterateChildFiberNodes;
    iterateDescendantFiberNodes: typeof iterateDescendantFiberNodes;
    loadLeakFilter: typeof loadLeakFilter;
    loadScenario: typeof loadScenario;
    loadTabsOrder: typeof loadTabsOrder;
    mapToObject: typeof mapToObject;
    markAllDetachedFiberNode: typeof markAllDetachedFiberNode;
    markAlternateFiberNode: typeof markAlternateFiberNode;
    markDetachedFiberNode: typeof markDetachedFiberNode;
    memCache: Record<string, any>;
    normalizeBaseUrl: typeof normalizeBaseUrl;
    objectToMap: typeof objectToMap;
    pathHasDetachedHTMLNode: typeof pathHasDetachedHTMLNode;
    pathHasEdgeWithIndex: typeof pathHasEdgeWithIndex;
    pathHasEdgeWithName: typeof pathHasEdgeWithName;
    pathHasNodeOrEdgeWithName: typeof pathHasNodeOrEdgeWithName;
    repeat: typeof repeat;
    resolveFilePath: typeof resolveFilePath;
    resolveSnapshotFilePath: typeof resolveSnapshotFilePath;
    runShell: typeof runShell;
    setChromiumBinary: typeof setChromiumBinary;
    setIsAlternateNode: typeof setIsAlternateNode;
    setIsRegularFiberNode: typeof setIsRegularFiberNode;
    shouldShowMoreInfo: typeof shouldShowMoreInfo;
    shuffleArray: typeof shuffleArray;
    simplifyTagAttributes: typeof simplifyTagAttributes;
    stripTagAttributes: typeof stripTagAttributes;
    throwError: typeof throwError;
    tryToMutePuppeteerWarning: typeof tryToMutePuppeteerWarning;
    upperCaseFirstCharacter: typeof upperCaseFirstCharacter;
};
export default _default;
//# sourceMappingURL=Utils.d.ts.map